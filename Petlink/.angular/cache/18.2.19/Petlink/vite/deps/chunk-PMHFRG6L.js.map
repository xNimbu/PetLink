{
  "version": 3,
  "sources": ["../../../../../../node_modules/idb/build/wrap-idb-value.js", "../../../../../../node_modules/idb/build/index.js"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n  }).catch(() => {});\n  // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Polyfill for objectStoreNames because of Edge.\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      }\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames, ...args) {\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  }\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function (...args) {\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n  return function (...args) {\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nconst unwrap = value => reverseTransformCache.get(value);\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, {\n  blocked,\n  upgrade,\n  blocking,\n  terminated\n} = {}) {\n  const request = indexedDB.open(name, version);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n    });\n  }\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event.newVersion, event));\n  }\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) {\n      db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n    }\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, {\n  blocked\n} = {}) {\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event));\n  }\n  return wrap(request).then(() => undefined);\n}\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n  const method = async function (storeName, ...args) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    if (useIndex) target = target.index(args.shift());\n    // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps(oldTraps => ({\n  ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\nexport { deleteDB, openDB };"],
  "mappings": "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",
  "names": ["target"]
}
